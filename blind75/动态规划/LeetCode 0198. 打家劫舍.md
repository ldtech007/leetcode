
> *题目链接：* https://leetcode.cn/problems/house-robber/

# LeetCode 198. 打家劫舍

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**举个例子：**
```
输入： [1,2,3,1]
输出： 4
解释： 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

## 知识回顾

**动态规划**是一种通过将原问题分解为子问题来求解复杂问题的算法思想。它通常用于**求解最优化问题**，例如最长公共子序列、背包问题等。动态规划的核心思想是将原问题分解为若干个子问题，通过求解子问题的最优解**自下而上**推导出原问题的最优解。

## 思路解析

本题是一道经典的动态规划问题，要找到解决动态规划问题的两个突破点：**推导出状态转移公式**和**边界条件处理**。

首先定义`dp[n]`表示总共有`n`间房所能偷到的最高金额。

对于`nums=[1, 2, 3, 1]`其所有可能的打劫路线如下：

![](https://raw.githubusercontent.com/ldtech007/leetcode/main/pic/lc-0198-01.png)

根节点到叶子节点就是一条打劫路线，每个节点是打劫到的金额，对于上面的例子`dp[4]`就等于所有打劫路线获取金额的最大值。

**状态转移公式需要分两种情况讨论：**
* 打劫路线包含第`4`间房（`nums[3]`），根据规则这个时候第`3`间房（`nums[2]`）一定是没有被打劫的，那么前`2`间房打劫到的最大金额加上第`4`间房打劫到的金额有可能是前`4`间房打劫的最大金额`dp[4] = dp[2] + nums[3]`。
* 打劫路线不包含第`4`间房（`nums[3]`），这个时候前`3`间房打劫到的最大金额有可能也是前`4`间房打劫的最大金额`dp[4] = dp[3]`。

上面两种情况选取最大值就可以得到`4`间房打劫到的最大金额`dp[4]=max(dp[2] + nums[3], dp[3])`;

扩展到一般情况dp[n]可以分解为dp[n-1]，dp[n-2]**两个子问题的组合**，得到**状态转移公式**：

```cpp
dp[n] = max{dp[n-2] + nums[n-1], dp[n-1]}
```

对于**边界条件** `dp[0] = 0`，`dp[1] = nums[0]`，`dp[2] = max{nums[0], nums[1]}`。

## C++ 代码

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int nums_len = nums.size();
        vector<int> dp(nums_len + 1, 0);
        if (nums_len > 0) {
            //边界条件
            dp[1] = nums[0];
        }
        if (nums_len > 1) {
            //边界条件
            dp[2] = max(nums[0], nums[1]);
        }
        for (int i = 3; i < nums_len + 1; ++i) {
            //状态转移公式
            dp[i] = max(dp[i-1], dp[i-2] + nums[i-1]);
        }
        return dp[nums_len];
    }
};

```

## 复杂度分析

**时间复杂度：** 只需要遍历一遍数组`nums`，所以时间复杂度为*O(n)*，`n`为`nums`的长度。

**空间复杂度：** 需要借助一个`dp`数组，空间复杂度为*O(n)*，`n`为`nums`的长度。

