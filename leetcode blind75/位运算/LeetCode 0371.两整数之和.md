
> *题目链接：* https://leetcode.cn/problems/sum-of-two-integers/

# LeetCode 371.两整数之和

## 题目描述

给你两个整数 `a` 和 `b` ，不使用 **运算符** `+` 和 `-` ​​​​​​​，计算并返回两整数之和。

**举个例子：**

```
输入：a = 1, b = 2
输出：3
```

## 知识回顾

1. `与`（`&`）运算的规则

```
1 & 1 = 1 
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0 
```
**两位同时为`1`，结果才为`1`。**

2. `或`（`|`）运算的规则

```
1 | 1 = 1 
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0 
```
**有一位为`1`，结果就为`1`。**

3. `异或`（`^`）运算的规则

```
1 ^ 1 = 0 
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0 
```
**两位不同，结果才为`1`。**

4. `左移`运算符 `<<`，可以将一个对象的二进制向左移`n`位，左边`n`位丢弃，右边`n`位补`0`。比如，`a = 1101`。

```
a << 2 = 0100
```

5. `右移`运算符 `>>`，可以将一个对象的二进制向右移`n`位，右边`n`位丢弃，左边`n`位补`0`。比如，`a = 1101`。

```
a >> 2 = 0011
```

## 思路解析

正常的十进制加法是加数和被加数每一位相加然后加上上一位的进位数，大于`10`就继续进位。 题目要求**不使用加法运算符**，所以我们只能通过`异或`（`^`）、`与`（`&`）、`左移`（`<<`）等位运算来实现。

加数和被加数对应的二进制按位相加，`1 + 1`对应位变成`0`，`1 + 0`对应位变成`1`，`0 + 0`对应位变成`0`，这个可以通过`异或`（`^`）运算来实现。

那么还有进位怎么处理呢？

继续观察会发现加数和被加数对应的二进制按位相加，只有`1 + 1`会存在进位`1`，可以通过`与`（`&`）和`左移`（`<<`）运算来实现。

根据上述规律，对于`a`，`b`两个整数，我们可以得到算法如下：
1. `temp_add = a ^ b`，获取到每一位的和（不包含进位），进入`步骤2`。
2. `temp_carry = (a & b) << 1`，获取到每一位的进位，进入`步骤3`。
3. 如果进位`temp_carry`为`0`，最终结果就是`temp_add`。如果进位`temp_carry`不为`0`，`a = temp_add`，`b = temp_carry`，进入`步骤1`。

## C++代码

```cpp
class Solution {
public:
    int getSum(int a, int b) {

        while (b) {
            int temp_add = a ^ b; //不包含进位a、b每位的和
            //a、b每位和的进位，左移有符号值会溢出，赋给无符号的会自动取模
            unsigned int temp_carry = (unsigned int)(a & b) << 1; 
            a = temp_add; //a、b每位的和赋值给a
            b = temp_carry; //a、b每位的进位赋值给b
        }
        return a;
    }
};
```

## 复杂度分析

**时间复杂度：** *O(1)*，因为整数在`32`位操作系统上占`32`位，最多计算`32`次`temp_carry`，故为常数的时间复杂度。

**空间复杂度：** 只使用了几个整型变量，故空间复杂度为*O(1)*。
